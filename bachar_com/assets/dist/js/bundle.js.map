{"version":3,"sources":["../../js/jump.js"],"names":["jumper","element","start","stop","offset","easing","a11y","distance","duration","timeStart","timeElapsed","next","callback","location","window","scrollY","pageYOffset","top","getBoundingClientRect","loop","timeCurrent","scrollTo","requestAnimationFrame","done","setAttribute","focus","jump","target","options","undefined","document","querySelector","singleton"],"mappings":"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","file":"bundle.js","sourcesContent":["import easeInOutQuad from './easing.js'\n\nconst jumper = () => {\n  // private variable cache\n  // no variables are created during a jump, preventing memory leaks\n\n  let element         // element to scroll to                   (node)\n\n  let start           // where scroll starts                    (px)\n  let stop            // where scroll stops                     (px)\n\n  let offset          // adjustment from the stop position      (px)\n  let easing          // easing function                        (function)\n  let a11y            // accessibility support flag             (boolean)\n\n  let distance        // distance of scroll                     (px)\n  let duration        // scroll duration                        (ms)\n\n  let timeStart       // time scroll started                    (ms)\n  let timeElapsed     // time spent scrolling thus far          (ms)\n\n  let next            // next scroll position                   (px)\n\n  let callback        // to call when done scrolling            (function)\n\n  // scroll position helper\n\n  function location () {\n    return window.scrollY || window.pageYOffset\n  }\n\n  // element offset helper\n\n  function top (element) {\n    return element.getBoundingClientRect().top + start\n  }\n\n  // rAF loop helper\n\n  function loop (timeCurrent) {\n    // store time scroll started, if not started already\n    if (!timeStart) {\n      timeStart = timeCurrent\n    }\n\n    // determine time spent scrolling so far\n    timeElapsed = timeCurrent - timeStart\n\n    // calculate next scroll position\n    next = easing(timeElapsed, start, distance, duration)\n\n    // scroll to it\n    window.scrollTo(0, next)\n\n    // check progress\n    timeElapsed < duration\n      ? window.requestAnimationFrame(loop)       // continue scroll loop\n      : done()                                   // scrolling is done\n  }\n\n  // scroll finished helper\n\n  function done () {\n    // account for rAF time rounding inaccuracies\n    window.scrollTo(0, start + distance)\n\n    // if scrolling to an element, and accessibility is enabled\n    if (element && a11y) {\n      // add tabindex indicating programmatic focus\n      element.setAttribute('tabindex', '-1')\n\n      // focus the element\n      element.focus()\n    }\n\n    // if it exists, fire the callback\n    if (typeof callback === 'function') {\n      callback()\n    }\n\n    // reset time for next jump\n    timeStart = false\n  }\n\n  // API\n\n  function jump (target, options = {}) {\n    // resolve options, or use defaults\n    duration = options.duration || 1000\n    offset = options.offset || 0\n    callback = options.callback                       // \"undefined\" is a suitable default, and won't be called\n    easing = options.easing || easeInOutQuad\n    a11y = options.a11y || false\n\n    // cache starting position\n    start = location()\n\n    // resolve target\n    switch (typeof target) {\n      // scroll from current position\n      case 'number':\n        element = undefined           // no element to scroll to\n        a11y = false                  // make sure accessibility is off\n        stop = start + target\n        break\n\n      // scroll to element (node)\n      // bounding rect is relative to the viewport\n      case 'object':\n        element = target\n        stop = top(element)\n        break\n\n      // scroll to element (selector)\n      // bounding rect is relative to the viewport\n      case 'string':\n        element = document.querySelector(target)\n        stop = top(element)\n        break\n    }\n\n    // resolve scroll distance, accounting for offset\n    distance = stop - start + offset\n\n    // resolve duration\n    switch (typeof options.duration) {\n      // number in ms\n      case 'number':\n        duration = options.duration\n        break\n\n      // function passed the distance of the scroll\n      case 'function':\n        duration = options.duration(distance)\n        break\n    }\n\n    // start the loop\n    window.requestAnimationFrame(loop)\n  }\n\n  // expose only the jump method\n  return jump\n}\n\n// export singleton\n\nconst singleton = jumper()\n\nexport default singleton"]}